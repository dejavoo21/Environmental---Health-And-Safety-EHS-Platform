/**
 * AccessRequestService - Phase 6
 * Handles self-service access request workflow
 */

const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { query } = require('../config/db');
const { sendEmail, isSmtpConfigured } = require('../utils/emailSender');
const env = require('../config/env');
const securityAuditService = require('./securityAuditService');

// Constants
const DEFAULT_EXPIRE_DAYS = 30;

/**
 * Submit a new access request
 * @param {Object} params - Request parameters
 * @returns {Promise<Object>} - Result with reference number
 */
const submitAccessRequest = async ({
  email,
  fullName,
  organisationCode,
  requestedRole = 'worker',
  reason = null,
  termsAccepted = false,
  ipAddress = null,
  userAgent = null
}) => {
  try {
    let org = null;

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email || !emailRegex.test(email)) {
      return { success: false, error: 'INVALID_EMAIL', message: 'Please enter a valid email address.' };
    }
    
    // Validate full name
    if (!fullName || fullName.length < 2 || fullName.length > 255) {
      return { success: false, error: 'INVALID_NAME', message: 'Please enter your full name (2-255 characters).' };
    }
    
    // Validate terms acceptance
    if (!termsAccepted) {
      return { success: false, error: 'TERMS_REQUIRED', message: 'You must accept the terms and conditions.' };
    }
    
    // Validate role
    if (!['worker', 'manager'].includes(requestedRole)) {
      return { success: false, error: 'INVALID_ROLE', message: 'Invalid role requested.' };
    }
    
    // Validate reason length if provided
    if (reason && reason.length > 500) {
      return { success: false, error: 'REASON_TOO_LONG', message: 'Reason must be 500 characters or less.' };
    }

    // Organisation code is optional - admin can assign later
    let organisationId = null;
    
    if (organisationCode && organisationCode.trim()) {
      // Look up organisation by slug (using slug instead of code since code column doesn't exist)
      const orgResult = await query(
        `SELECT id, name, access_request_enabled, access_request_auto_expire_days 
         FROM organisations WHERE slug = $1 AND is_active = TRUE`,
        [organisationCode.toLowerCase().trim()]
      );
      
      if (orgResult.rowCount === 0) {
        return { success: false, error: 'ORG_NOT_FOUND', message: 'Organisation code not found. Please check and try again, or leave blank to request without specifying an organisation.' };
      }
      
      org = orgResult.rows[0];
      organisationId = org.id;
      
      // Check if access requests are enabled for this org
      if (!org.access_request_enabled) {
        return { success: false, error: 'REQUESTS_DISABLED', message: 'This organisation is not accepting access requests at this time.' };
      }
    }
    
    // Check if email is already registered (only if organisation provided)
    if (organisationId) {
      const existingUser = await query(
        `SELECT id FROM users WHERE email = $1 AND organisation_id = $2`,
        [email.toLowerCase().trim(), organisationId]
      );
      
      if (existingUser.rowCount > 0) {
        return { success: false, error: 'EMAIL_EXISTS', message: 'An account with this email already exists.' };
      }
    }
    
    // Check for existing pending request (only if organisation provided)
    if (organisationId) {
      const existingRequest = await query(
        `SELECT id, reference_number FROM access_requests 
         WHERE email = $1 AND organisation_id = $2 AND status = 'pending'`,
        [email.toLowerCase().trim(), organisationId]
      );
      
      if (existingRequest.rowCount > 0) {
        return { 
          success: false, 
          error: 'REQUEST_EXISTS', 
          message: 'You already have a pending request.',
          referenceNumber: existingRequest.rows[0].reference_number
        };
      }
    }
  
    // Calculate expiry date (use default if no org provided)
    const expireDays = organisationId ? org?.access_request_auto_expire_days : null;
    const expiresAt = new Date(Date.now() + (expireDays || DEFAULT_EXPIRE_DAYS) * 24 * 60 * 60 * 1000);
    
    // Create access request (reference number generated by trigger)
    const insertResult = await query(
      `INSERT INTO access_requests (
        email, full_name, organisation_id, organisation_code, requested_role,
        reason, terms_accepted, ip_address, user_agent, expires_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING id, reference_number, created_at`,
      [
        email.toLowerCase().trim(),
        fullName.trim(),
        organisationId,
        organisationCode ? organisationCode.toLowerCase().trim() : null,
        requestedRole,
        reason,
        termsAccepted,
        ipAddress,
        userAgent,
        expiresAt
      ]
    );
    
    const request = insertResult.rows[0];
    
    // Log the event (only if organisation exists)
    if (organisationId) {
      await securityAuditService.logAccessRequestCreated({
        organisationId: organisationId,
        referenceNumber: request.reference_number,
        email: email.toLowerCase().trim(),
        ipAddress,
        userAgent
      });
      
      // Send confirmation email when SMTP is configured.
      if (isSmtpConfigured()) {
        await sendAccessRequestConfirmationEmail({
          email: email.toLowerCase().trim(),
          fullName: fullName.trim(),
          referenceNumber: request.reference_number,
          organisationName: org.name
        });
      }
    }
    
    return {
      success: true,
      referenceNumber: request.reference_number,
      message: 'Your access request has been submitted. You will be notified when it is reviewed.'
    };
  } catch (err) {
    console.error('[AccessRequest] Error submitting request:', {
      message: err.message,
      code: err.code,
      severity: err.severity,
    });
    
    // Check for database connection errors
    if (err.code === 'ECONNREFUSED' || err.message?.includes('connect') || err.message?.includes('Connection') || err.message?.includes('ENOENT')) {
      return { 
        success: false, 
        error: 'DB_CONNECTION_ERROR', 
        message: 'The system is temporarily unavailable. Our team has been notified. Please try again in a few moments.' 
      };
    }
    
    if (err.code === 'ETIMEDOUT' || err.message?.includes('timeout')) {
      return { 
        success: false, 
        error: 'DB_TIMEOUT', 
        message: 'The request took too long to process. Please try again.' 
      };
    }
    
    // For any other database error, return a safe message
    if (err.code?.startsWith('EACCES') || err.code?.startsWith('ENOTFOUND')) {
      return { 
        success: false, 
        error: 'SERVICE_UNAVAILABLE', 
        message: 'The authentication service is currently unavailable. Please try again shortly.' 
      };
    }
    
    // For all other errors (including database errors), return safe message instead of throwing
    console.error('[AccessRequest] Unhandled error details:', err);
    return {
      success: false,
      error: 'SYSTEM_ERROR',
      message: 'An unexpected error occurred. Our team is investigating. Please try again later.'
    };
  }
};

/**
 * List access requests for an organisation (admin)
 * @param {Object} params - Query parameters
 * @returns {Promise<Object>} - Paginated results
 */
const listAccessRequests = async ({
  organisationId,
  status = null,
  search = null,
  page = 1,
  limit = 20
}) => {
  const conditions = [];
  const values = [];
  let paramIndex = 1;
  
  // Filter by organisation - admins should only see requests for their organisation
  conditions.push(`ar.organisation_id = $${paramIndex++}`);
  values.push(organisationId);
  
  if (status && status !== 'all') {
    conditions.push(`ar.status = $${paramIndex++}`);
    values.push(status);
  }
  
  if (search) {
    conditions.push(`(ar.email ILIKE $${paramIndex} OR ar.full_name ILIKE $${paramIndex} OR ar.reference_number ILIKE $${paramIndex})`);
    values.push(`%${search}%`);
    paramIndex++;
  }
  
  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
  const offset = (page - 1) * limit;
  
  // Get total count
  const countResult = await query(
    `SELECT COUNT(*) FROM access_requests ar ${whereClause}`,
    values
  );
  const total = parseInt(countResult.rows[0].count, 10);
  
  // Get paginated data
  const dataResult = await query(
    `SELECT 
      ar.id, ar.reference_number, ar.email, ar.full_name, ar.requested_role,
      ar.reason, ar.status, ar.created_at, ar.expires_at,
      u.name AS decided_by_name, ar.decision_at
     FROM access_requests ar
     LEFT JOIN users u ON u.id = ar.decision_by
     ${whereClause}
     ORDER BY 
       CASE WHEN ar.status = 'pending' THEN 0 ELSE 1 END,
       ar.created_at DESC
     LIMIT $${paramIndex++} OFFSET $${paramIndex}`,
    [...values, limit, offset]
  );
  
  return {
    data: dataResult.rows.map(row => ({
      id: row.id,
      referenceNumber: row.reference_number,
      email: row.email,
      fullName: row.full_name,
      requestedRole: row.requested_role,
      reason: row.reason,
      status: row.status,
      createdAt: row.created_at,
      expiresAt: row.expires_at,
      decidedByName: row.decided_by_name,
      decisionAt: row.decision_at
    })),
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  };
};

/**
 * Get access request details
 * @param {string} id - Request ID
 * @param {string} organisationId - Organisation ID
 * @returns {Promise<Object|null>} - Request details or null
 */
const getAccessRequest = async (id, organisationId) => {
  const result = await query(
    `SELECT 
      ar.*, u.name AS decided_by_name, u.email AS decided_by_email
     FROM access_requests ar
     LEFT JOIN users u ON u.id = ar.decision_by
     WHERE ar.id = $1 AND ar.organisation_id = $2`,
    [id, organisationId]
  );
  
  if (result.rowCount === 0) {
    return null;
  }
  
  const row = result.rows[0];
  return {
    id: row.id,
    referenceNumber: row.reference_number,
    email: row.email,
    fullName: row.full_name,
    organisationId: row.organisation_id,
    organisationCode: row.organisation_code,
    requestedRole: row.requested_role,
    reason: row.reason,
    status: row.status,
    decisionBy: row.decision_by,
    decidedByName: row.decided_by_name,
    decidedByEmail: row.decided_by_email,
    decisionAt: row.decision_at,
    decisionReason: row.decision_reason,
    ipAddress: row.ip_address,
    userAgent: row.user_agent,
    termsAccepted: row.terms_accepted,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
    expiresAt: row.expires_at
  };
};

/**
 * Approve an access request
 * @param {Object} params - Approval parameters
 * @returns {Promise<Object>} - Result with created user
 */
const approveAccessRequest = async ({
  requestId,
  organisationId,
  adminUserId,
  assignedRole = null,
  sendWelcomeEmail = true,
  ipAddress = null,
  userAgent = null
}) => {
  // Get the request
  const request = await getAccessRequest(requestId, organisationId);
  
  if (!request) {
    return { success: false, error: 'NOT_FOUND', message: 'Access request not found.' };
  }
  
  if (request.status !== 'pending') {
    return { success: false, error: 'ALREADY_PROCESSED', message: `This request has already been ${request.status}.` };
  }
  
  if (new Date(request.expiresAt) < new Date()) {
    // Mark as expired
    await query(
      `UPDATE access_requests SET status = 'expired', updated_at = NOW() WHERE id = $1`,
      [requestId]
    );
    return { success: false, error: 'EXPIRED', message: 'This request has expired.' };
  }
  
  // Check if email is still available
  const existingUser = await query(
    `SELECT id FROM users WHERE email = $1 AND organisation_id = $2`,
    [request.email, organisationId]
  );
  
  if (existingUser.rowCount > 0) {
    return { success: false, error: 'EMAIL_EXISTS', message: 'An account with this email already exists.' };
  }
  
  // Generate temporary password
  const tempPassword = generateTemporaryPassword();
  const passwordHash = await bcrypt.hash(tempPassword, 12);
  
  // Create user
  const userResult = await query(
    `INSERT INTO users (
      email, name, password_hash, role, organisation_id, is_active, force_password_change
    ) VALUES ($1, $2, $3, $4, $5, TRUE, TRUE)
    RETURNING id, email, name, role`,
    [
      request.email,
      request.fullName,
      passwordHash,
      assignedRole || request.requestedRole,
      organisationId
    ]
  );
  
  const newUser = userResult.rows[0];
  
  // Update access request
  await query(
    `UPDATE access_requests 
     SET status = 'approved', decision_by = $1, decision_at = NOW(), updated_at = NOW()
     WHERE id = $2`,
    [adminUserId, requestId]
  );
  
  // Log the event
  await securityAuditService.logAccessRequestApproved({
    organisationId,
    userId: adminUserId,
    targetUserId: newUser.id,
    referenceNumber: request.referenceNumber,
    ipAddress,
    userAgent
  });
  
  // Send welcome email if configured
  if (sendWelcomeEmail && isSmtpConfigured()) {
    await sendApprovalEmail({
      email: newUser.email,
      name: newUser.name,
      tempPassword,
      loginUrl: `${env.frontendUrl}/login`
    });
  }
  
  return {
    success: true,
    message: 'Access request approved. User account created.',
    user: {
      id: newUser.id,
      email: newUser.email,
      name: newUser.name,
      role: newUser.role
    },
    // Only include temp password in dev for testing
    ...(env.nodeEnv === 'development' && { _devTempPassword: tempPassword })
  };
};

/**
 * Reject an access request
 * @param {Object} params - Rejection parameters
 * @returns {Promise<Object>} - Result
 */
const rejectAccessRequest = async ({
  requestId,
  organisationId,
  adminUserId,
  reason = null,
  sendEmail = true,
  ipAddress = null,
  userAgent = null
}) => {
  // Get the request
  const request = await getAccessRequest(requestId, organisationId);
  
  if (!request) {
    return { success: false, error: 'NOT_FOUND', message: 'Access request not found.' };
  }
  
  if (request.status !== 'pending') {
    return { success: false, error: 'ALREADY_PROCESSED', message: `This request has already been ${request.status}.` };
  }
  
  // Update access request
  await query(
    `UPDATE access_requests 
     SET status = 'rejected', decision_by = $1, decision_at = NOW(), 
         decision_reason = $2, updated_at = NOW()
     WHERE id = $3`,
    [adminUserId, reason, requestId]
  );
  
  // Log the event
  await securityAuditService.logAccessRequestRejected({
    organisationId,
    userId: adminUserId,
    referenceNumber: request.referenceNumber,
    reason,
    ipAddress,
    userAgent
  });
  
  // Send rejection email if configured (polite, no reason given)
  if (sendEmail && isSmtpConfigured()) {
    await sendRejectionEmail({
      email: request.email,
      name: request.fullName
    });
  }
  
  return {
    success: true,
    message: 'Access request rejected.'
  };
};

/**
 * Generate a temporary password
 * @returns {string} - 12-character password
 */
const generateTemporaryPassword = () => {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789!@#$%';
  let password = '';
  const bytes = crypto.randomBytes(12);
  for (let i = 0; i < 12; i++) {
    password += chars[bytes[i] % chars.length];
  }
  return password;
};

/**
 * Send access request confirmation email
 */
const sendAccessRequestConfirmationEmail = async ({ email, fullName, referenceNumber, organisationName }) => {
  const subject = 'EHS Portal - Access Request Received';
  const text = `
Hi ${fullName},

Your access request for ${organisationName} has been received.

Reference Number: ${referenceNumber}

You will receive another email once your request has been reviewed.

Best regards,
EHS Portal Team
  `.trim();
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .reference { background: #f0f0f0; padding: 10px 20px; border-radius: 6px; margin: 20px 0; font-size: 18px; }
    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Access Request Received</h2>
    <p>Hi ${fullName},</p>
    <p>Your access request for <strong>${organisationName}</strong> has been received.</p>
    <div class="reference">Reference Number: <strong>${referenceNumber}</strong></div>
    <p>You will receive another email once your request has been reviewed.</p>
    <div class="footer">
      <p>Best regards,<br>EHS Portal Team</p>
    </div>
  </div>
</body>
</html>
  `.trim();
  
  await sendEmail({ to: email, subject, text, html });
};

/**
 * Send welcome email after approval
 */
const sendApprovalEmail = async ({ email, name, tempPassword, loginUrl }) => {
  const subject = 'EHS Portal - Your Account is Ready';
  const text = `
Hi ${name},

Your access request has been approved! Your account is now ready to use.

You can log in at: ${loginUrl}

Your temporary password is: ${tempPassword}

For security, you will be required to change your password on first login.

Best regards,
EHS Portal Team
  `.trim();
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .button { display: inline-block; padding: 12px 24px; background-color: #22c55e; color: white !important; text-decoration: none; border-radius: 6px; margin: 20px 0; }
    .password { background: #f0f0f0; padding: 10px 20px; border-radius: 6px; margin: 20px 0; font-family: monospace; font-size: 18px; }
    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Your Account is Ready!</h2>
    <p>Hi ${name},</p>
    <p>Your access request has been approved! Your account is now ready to use.</p>
    <a href="${loginUrl}" class="button">Log In Now</a>
    <p>Your temporary password is:</p>
    <div class="password">${tempPassword}</div>
    <p><strong>For security, you will be required to change your password on first login.</strong></p>
    <div class="footer">
      <p>Best regards,<br>EHS Portal Team</p>
    </div>
  </div>
</body>
</html>
  `.trim();
  
  await sendEmail({ to: email, subject, text, html });
};

/**
 * Send rejection email (polite, no reason given)
 */
const sendRejectionEmail = async ({ email, name }) => {
  const subject = 'EHS Portal - Access Request Update';
  const text = `
Hi ${name},

Thank you for your interest in the EHS Portal.

Unfortunately, we are unable to approve your access request at this time.

If you believe this is in error or have questions, please contact your organisation's administrator.

Best regards,
EHS Portal Team
  `.trim();
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Access Request Update</h2>
    <p>Hi ${name},</p>
    <p>Thank you for your interest in the EHS Portal.</p>
    <p>Unfortunately, we are unable to approve your access request at this time.</p>
    <p>If you believe this is in error or have questions, please contact your organisation's administrator.</p>
    <div class="footer">
      <p>Best regards,<br>EHS Portal Team</p>
    </div>
  </div>
</body>
</html>
  `.trim();
  
  await sendEmail({ to: email, subject, text, html });
};

/**
 * Expire old pending requests (scheduled job)
 */
const expirePendingRequests = async () => {
  const result = await query(
    `UPDATE access_requests 
     SET status = 'expired', updated_at = NOW()
     WHERE status = 'pending' AND expires_at < NOW()
     RETURNING id, reference_number, organisation_id`
  );
  
  // Log events for each expired request
  for (const row of result.rows) {
    await securityAuditService.logSecurityEvent({
      eventType: 'ACCESS_REQUEST_EXPIRED',
      organisationId: row.organisation_id,
      metadata: { referenceNumber: row.reference_number }
    });
  }
  
  return { expired: result.rowCount };
};

module.exports = {
  submitAccessRequest,
  listAccessRequests,
  getAccessRequest,
  approveAccessRequest,
  rejectAccessRequest,
  expirePendingRequests
};
